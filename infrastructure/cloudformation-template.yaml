AWSTemplateFormatVersion: "2010-09-09"
Description: "S3 Bucket Management System with Authentication"

Parameters:
  NotificationEmail:
    Type: String
    Description: Email for notifications
    Default: your-email@example.com
  Environment:
    Type: String
    Default: dev
    AllowedValues: [dev, staging, prod]

Resources:
  # Cognito User Pool
  CognitoUserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub "${Environment}-bucket-management-users"
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireUppercase: true
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: false
      AutoVerifiedAttributes:
        - email
      MfaConfiguration: "OFF"
      EmailConfiguration:
        EmailSendingAccount: COGNITO_DEFAULT
      Schema:
        - Name: email
          AttributeDataType: String
          Required: true
          Mutable: true
        - Name: name
          AttributeDataType: String
          Required: true
          Mutable: true

  CognitoUserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      UserPoolId: !Ref CognitoUserPool
      ClientName: !Sub "${Environment}-bucket-management-client"
      GenerateSecret: false
      ExplicitAuthFlows:
        - ALLOW_USER_PASSWORD_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
      PreventUserExistenceErrors: ENABLED
      TokenValidityUnits:
        AccessToken: hours
        IdToken: hours
        RefreshToken: days
      AccessTokenValidity: 1
      IdTokenValidity: 1
      RefreshTokenValidity: 30

  CognitoIdentityPool:
    Type: AWS::Cognito::IdentityPool
    DependsOn: CognitoUserPoolClient
    Properties:
      IdentityPoolName: !Sub "${Environment}-bucket-management-identity-pool"
      AllowUnauthenticatedIdentities: false
      CognitoIdentityProviders:
        - ClientId: !Ref CognitoUserPoolClient
          ProviderName: !Sub cognito-idp.${AWS::Region}.amazonaws.com/${CognitoUserPool}          

  # DynamoDB Table for metadata
  BucketMetadataTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${Environment}-bucket-metadata"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: project_name
          AttributeType: S
        - AttributeName: bucket_name
          AttributeType: S
        - AttributeName: user_id
          AttributeType: S
      KeySchema:
        - AttributeName: project_name
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: bucket-name-index
          KeySchema:
            - AttributeName: bucket_name
              KeyType: HASH
          Projection:
            ProjectionType: ALL
        - IndexName: user-id-index
          KeySchema:
            - AttributeName: user_id
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true

  # SNS Topic for notifications
  BucketNotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub "${Environment}-bucket-notifications"
      Subscription:
        - Endpoint: !Ref NotificationEmail
          Protocol: email

  # IAM Role for Lambda functions
  BucketManagementRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${Environment}-bucket-management-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BucketManagementPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - s3:CreateBucket
                  - s3:DeleteBucket
                  - s3:GetBucketLocation
                  - s3:ListBucket
                  - s3:PutBucketPublicAccessBlock
                  - s3:PutBucketVersioning
                  - s3:PutBucketEncryption
                  - s3:HeadBucket
                Resource: "*"
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt BucketMetadataTable.Arn
                  - !Sub "${BucketMetadataTable.Arn}/index/*"
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource: !Ref BucketNotificationTopic

  # Lambda: Create Bucket (Enhanced)
  CreateBucketFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${Environment}-create-bucket"
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt BucketManagementRole.Arn
      Timeout: 30
      MemorySize: 128
      Environment:
        Variables:
          TABLE_NAME: !Ref BucketMetadataTable
          SNS_TOPIC: !Ref BucketNotificationTopic
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import uuid
          import re
          from datetime import datetime

          s3 = boto3.client('s3')
          dynamodb = boto3.resource('dynamodb')
          sns = boto3.client('sns')

          table = dynamodb.Table(os.environ['TABLE_NAME'])
          topic_arn = os.environ['SNS_TOPIC']
          environment = os.environ['ENVIRONMENT']

          def lambda_handler(event, context):
              try:
                  # Extract user info from Cognito
                  user_id = None
                  user_email = None
                  
                  if 'requestContext' in event and 'authorizer' in event['requestContext']:
                      claims = event['requestContext']['authorizer']['claims']
                      user_id = claims.get('sub')
                      user_email = claims.get('email')
                  
                  body = json.loads(event['body']) if isinstance(event['body'], str) else event['body']
                  project_name = body['project_name'].lower().strip()
                  
                  # Validate project name
                  if not re.match(r'^[a-z0-9-]+$', project_name):
                      return {
                          'statusCode': 400,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({'error': 'Project name must contain only lowercase letters, numbers, and hyphens'})
                      }
                  
                  if len(project_name) < 3 or len(project_name) > 50:
                      return {
                          'statusCode': 400,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({'error': 'Project name must be between 3 and 50 characters'})
                      }
                  
                  # Generate unique bucket name
                  bucket_name = f"{environment}-{project_name}-{str(uuid.uuid4())[:8]}"
                  
                  # Check if project already exists for this user
                  try:
                      response = table.get_item(Key={'project_name': f"{user_id}#{project_name}"})
                      if 'Item' in response:
                          return {
                              'statusCode': 409,
                              'headers': {'Content-Type': 'application/json'},
                              'body': json.dumps({'error': 'Project already exists for this user'})
                          }
                  except Exception as e:
                      pass
                  
                  # Create S3 bucket
                  s3.create_bucket(Bucket=bucket_name)
                  
                  # Configure bucket security
                  s3.put_bucket_public_access_block(
                      Bucket=bucket_name,
                      PublicAccessBlockConfiguration={
                          'BlockPublicAcls': True,
                          'IgnorePublicAcls': True,
                          'BlockPublicPolicy': True,
                          'RestrictPublicBuckets': True
                      }
                  )
                  
                  # Enable encryption
                  s3.put_bucket_encryption(
                      Bucket=bucket_name,
                      ServerSideEncryptionConfiguration={
                          'Rules': [{
                              'ApplyServerSideEncryptionByDefault': {
                                  'SSEAlgorithm': 'AES256'
                              }
                          }]
                      }
                  )
                  
                  # Store metadata
                  table.put_item(
                      Item={
                          'project_name': f"{user_id}#{project_name}",
                          'bucket_name': bucket_name,
                          'user_id': user_id,
                          'user_email': user_email or 'unknown',
                          'display_name': project_name,
                          'created_at': datetime.utcnow().isoformat(),
                          'status': 'active',
                          'last_checked': datetime.utcnow().isoformat(),
                          'environment': environment
                      }
                  )
                  
                  # Send notification
                  sns.publish(
                      TopicArn=topic_arn,
                      Message=f"Bucket {bucket_name} created for project {project_name} by user {user_email}",
                      Subject="S3 Bucket Created"
                  )
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({
                          'project_name': project_name,
                          'bucket_name': bucket_name,
                          'status': 'created'
                      })
                  }
                  
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {'Content-Type': 'application/json'},
                      'body': json.dumps({'error': 'Internal server error'})
                  }

  # Lambda: List Buckets (Enhanced)
  ListBucketsFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${Environment}-list-buckets"
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt BucketManagementRole.Arn
      Timeout: 30
      MemorySize: 128
      Environment:
        Variables:
          TABLE_NAME: !Ref BucketMetadataTable
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from boto3.dynamodb.conditions import Key

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TABLE_NAME'])

          def lambda_handler(event, context):
              try:
                  # Extract user info from Cognito
                  user_id = None
                  if 'requestContext' in event and 'authorizer' in event['requestContext']:
                      claims = event['requestContext']['authorizer']['claims']
                      user_id = claims.get('sub')
                  
                  if not user_id:
                      return {
                          'statusCode': 401,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({'error': 'Unauthorized'})
                      }
                  
                  # Get query parameters
                  query_params = event.get('queryStringParameters', {}) or {}
                  project_name = query_params.get('project_name')
                  
                  if project_name:
                      # Get specific project for this user
                      response = table.get_item(Key={'project_name': f"{user_id}#{project_name}"})
                      if 'Item' in response:
                          item = response['Item']
                          # Remove internal user_id from response
                          item.pop('user_id', None)
                          return {
                              'statusCode': 200,
                              'headers': {
                                  'Content-Type': 'application/json',
                                  'Access-Control-Allow-Origin': '*'
                              },
                              'body': json.dumps(item, default=str)
                          }
                      else:
                          return {
                              'statusCode': 404,
                              'headers': {'Content-Type': 'application/json'},
                              'body': json.dumps({'error': 'Project not found'})
                          }
                  else:
                      # List all projects for this user
                      response = table.query(
                          IndexName='user-id-index',
                          KeyConditionExpression=Key('user_id').eq(user_id)
                      )
                      
                      items = response['Items']
                      # Clean up items for response
                      for item in items:
                          item.pop('user_id', None)
                      
                      return {
                          'statusCode': 200,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*'
                          },
                          'body': json.dumps(items, default=str)
                      }
                      
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {'Content-Type': 'application/json'},
                      'body': json.dumps({'error': 'Internal server error'})
                  }

  # Lambda: Monitor and Heal Buckets (Enhanced)
  MonitorBucketsFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${Environment}-monitor-buckets"
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt BucketManagementRole.Arn
      Timeout: 300
      MemorySize: 256
      Environment:
        Variables:
          TABLE_NAME: !Ref BucketMetadataTable
          SNS_TOPIC: !Ref BucketNotificationTopic
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime

          s3 = boto3.client('s3')
          dynamodb = boto3.resource('dynamodb')
          sns = boto3.client('sns')

          table = dynamodb.Table(os.environ['TABLE_NAME'])
          topic_arn = os.environ['SNS_TOPIC']
          environment = os.environ['ENVIRONMENT']

          def lambda_handler(event, context):
              processed_buckets = 0
              healed_buckets = 0
              
              try:
                  # Scan all active buckets
                  response = table.scan(
                      FilterExpression='#status = :status',
                      ExpressionAttributeNames={'#status': 'status'},
                      ExpressionAttributeValues={':status': 'active'}
                  )
                  
                  for item in response['Items']:
                      bucket_name = item['bucket_name']
                      project_name = item['project_name']
                      user_email = item.get('user_email', 'unknown')
                      display_name = item.get('display_name', project_name)
                      
                      processed_buckets += 1
                      
                      try:
                          # Check if bucket exists
                          s3.head_bucket(Bucket=bucket_name)
                          
                          # Update last_checked
                          table.update_item(
                              Key={'project_name': project_name},
                              UpdateExpression='SET last_checked = :timestamp',
                              ExpressionAttributeValues={
                                  ':timestamp': datetime.utcnow().isoformat()
                              }
                          )
                          
                      except s3.exceptions.NoSuchBucket:
                          # Bucket doesn't exist, recreate it
                          if recreate_bucket(bucket_name, project_name, user_email, display_name):
                              healed_buckets += 1
                          
                      except Exception as e:
                          print(f"Error checking bucket {bucket_name}: {str(e)}")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Monitoring completed',
                          'processed_buckets': processed_buckets,
                          'healed_buckets': healed_buckets
                      })
                  }
                  
              except Exception as e:
                  print(f"Error in monitoring: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }

          def recreate_bucket(bucket_name, project_name, user_email, display_name):
              try:
                  # Recreate bucket
                  s3.create_bucket(Bucket=bucket_name)
                  
                  # Configure security
                  s3.put_bucket_public_access_block(
                      Bucket=bucket_name,
                      PublicAccessBlockConfiguration={
                          'BlockPublicAcls': True,
                          'IgnorePublicAcls': True,
                          'BlockPublicPolicy': True,
                          'RestrictPublicBuckets': True
                      }
                  )
                  
                  # Enable encryption
                  s3.put_bucket_encryption(
                      Bucket=bucket_name,
                      ServerSideEncryptionConfiguration={
                          'Rules': [{
                              'ApplyServerSideEncryptionByDefault': {
                                  'SSEAlgorithm': 'AES256'
                              }
                          }]
                      }
                  )
                  
                  # Update metadata
                  table.update_item(
                      Key={'project_name': project_name},
                      UpdateExpression='SET last_checked = :timestamp, healed_at = :timestamp, heal_count = if_not_exists(heal_count, :zero) + :one',
                      ExpressionAttributeValues={
                          ':timestamp': datetime.utcnow().isoformat(),
                          ':zero': 0,
                          ':one': 1
                      }
                  )
                  
                  # Send healing notification
                  sns.publish(
                      TopicArn=topic_arn,
                      Message=f"Bucket {bucket_name} for project '{display_name}' was automatically recreated.\n\nUser: {user_email}\nTime: {datetime.utcnow().isoformat()}\n\nThe bucket was deleted and has been restored with the same configuration.",
                      Subject=f"S3 Bucket Healed - {display_name}"
                  )
                  
                  print(f"Bucket {bucket_name} recreated successfully")
                  return True
                  
              except Exception as e:
                  print(f"Error recreating bucket {bucket_name}: {str(e)}")
                  return False

  # API Gateway
  BucketManagementAPI:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "${Environment}-bucket-management-api"
      Description: API for S3 bucket management
      EndpointConfiguration:
        Types:
          - REGIONAL

  # Cognito Authorizer
  CognitoAuthorizer:
    Type: AWS::ApiGateway::Authorizer
    DependsOn: CognitoUserPool
    Properties:
      Name: CognitoAuthorizer
      Type: COGNITO_USER_POOLS
      IdentitySource: method.request.header.Authorization
      RestApiId: !Ref BucketManagementAPI
      ProviderARNs:
        - !GetAtt CognitoUserPool.Arn

  # CORS Support
  CorsOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref BucketManagementAPI
      ResourceId: !GetAtt BucketManagementAPI.RootResourceId
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  # API Gateway Resources and Methods
  BucketsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref BucketManagementAPI
      ParentId: !GetAtt BucketManagementAPI.RootResourceId
      PathPart: buckets

  BucketsOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref BucketManagementAPI
      ResourceId: !Ref BucketsResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  CreateBucketMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref BucketManagementAPI
      ResourceId: !Ref BucketsResource
      HttpMethod: POST
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref CognitoAuthorizer
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
          - LambdaArn: !GetAtt CreateBucketFunction.Arn

  ListBucketsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref BucketManagementAPI
      ResourceId: !Ref BucketsResource
      HttpMethod: GET
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref CognitoAuthorizer
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
          - LambdaArn: !GetAtt ListBucketsFunction.Arn

  # Lambda permissions for API Gateway
  CreateBucketPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CreateBucketFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${BucketManagementAPI}/*/POST/buckets"

  ListBucketsPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ListBucketsFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${BucketManagementAPI}/*/GET/buckets"

  # API Gateway Deployment
  APIDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - CreateBucketMethod
      - ListBucketsMethod
      - BucketsOptionsMethod
      - CorsOptionsMethod
    Properties:
      RestApiId: !Ref BucketManagementAPI
      StageName: !Ref Environment

  # EventBridge Rule for monitoring
  MonitoringRule:
    Type: AWS::Events::Rule
    Properties:
      Description: "Monitor S3 buckets every 5 minutes"
      ScheduleExpression: "rate(5 minutes)"
      State: ENABLED
      Targets:
        - Arn: !GetAtt MonitorBucketsFunction.Arn
          Id: "MonitorBucketsTarget"

  # EventBridge permission for Lambda
  MonitoringPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref MonitorBucketsFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt MonitoringRule.Arn

  # IAM Role for authenticated Cognito users
  CognitoAuthRole:
    Type: AWS::IAM::Role
    DependsOn: CognitoIdentityPool
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Federated: cognito-identity.amazonaws.com
            Action: sts:AssumeRoleWithWebIdentity
            Condition:
              StringEquals:
                "cognito-identity.amazonaws.com:aud": !Ref CognitoIdentityPool
              "ForAnyValue:StringLike":
                "cognito-identity.amazonaws.com:amr": authenticated
      Policies:
        - PolicyName: CognitoAuthPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - execute-api:Invoke
                Resource: "*"

  CognitoIdentityPoolRoleAttachment:
    Type: AWS::Cognito::IdentityPoolRoleAttachment
    DependsOn: CognitoAuthRole
    Properties:
      IdentityPoolId: !Ref CognitoIdentityPool
      Roles:
        authenticated: !GetAtt CognitoAuthRole.Arn

Outputs:
  APIEndpoint:
    Description: API Gateway endpoint
    Value: !Sub "https://${BucketManagementAPI}.execute-api.${AWS::Region}.amazonaws.com/${Environment}"
    Export:
      Name: !Sub "${Environment}-bucket-api-endpoint"

  UserPoolId:
    Description: Cognito User Pool ID
    Value: !Ref CognitoUserPool
    Export:
      Name: !Sub "${Environment}-user-pool-id"

  UserPoolClientId:
    Description: Cognito User Pool Client ID
    Value: !Ref CognitoUserPoolClient
    Export:
      Name: !Sub "${Environment}-user-pool-client-id"

  IdentityPoolId:
    Description: Cognito Identity Pool ID
    Value: !Ref CognitoIdentityPool
    Export:
      Name: !Sub "${Environment}-identity-pool-id"

  DynamoDBTable:
    Description: DynamoDB table name
    Value: !Ref BucketMetadataTable
    Export:
      Name: !Sub "${Environment}-bucket-metadata-table"

  SNSTopic:
    Description: SNS topic ARN
    Value: !Ref BucketNotificationTopic
    Export:
      Name: !Sub "${Environment}-sns-topic"